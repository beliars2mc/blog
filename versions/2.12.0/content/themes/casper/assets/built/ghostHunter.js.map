{"version":3,"sources":["ghostHunter.js"],"names":["$","console","log","lunr","require","fn","ghostHunter","options","opts","extend","defaults","results","pluginMethods","init","this","resultsData","onPageLoad","onKeyUp","result_template","info_template","displaySearchInfo","zeroResultsInfo","before","onComplete","includepages","filterfields","subpath","item_preprocessor","indexing_start","indexing_end","includebodysearch","getSubpathKey","str","replace","lastTimeoutID","settleIDs","each","newAttr","getAttribute","setAttribute","grabAndIndex","blogData","latestPost","params","limit","include","formats","filter","me","get","ghost","url","api","done","data","idxSrc","posts","index","ref","field","forEach","arrayItem","itemDate","Date","updated_at","getTime","tag_arr","tags","map","v","name","meta_description","category","join","length","parsedData","id","String","title","description","custom_excerpt","pubDate","published_at","tag","plaintext","add","date","d","localUrl","getDate","getMonth","getFullYear","link","Object","assign","subpathKey","localStorage","setItem","JSON","stringify","e","warn","isInit","target","that","window","setTimeout","loadAPI","focus","closest","submit","preventDefault","find","val","keydown","event","which","keyup","getItem","Index","load","parse","fields","call","value","clearTimeout","toLowerCase","thingsFound","valueSplit","split","i","ilen","push","query","q","term","usePipeline","boost","wildcard","Query","TRAILING","editDistance","searchResult","slice","j","jlen","otherRefs","k","klen","concat","empty","append","format","amount","children","eq","replaceWith","lunrref","postData","listItems","currentRefs","newRefs","steps","Levenshtein","getSteps","apiData","step","remove","html","pos","after","bind","clear","t","a","b","r","jQuery"],"mappings":"CAMA,SAAWA,GAETC,QAAQC,IAAI,QAGZ,IAAIC,EAAKC,QAAQ,gBAKjBJ,EAAEK,GAAGC,YAAe,SAAUC,GAG5B,IAAIC,EAASR,EAAES,OAAQ,GAAIT,EAAEK,GAAGC,YAAYI,SAAUH,GACtD,GAAIC,EAAKG,QAGP,OADAC,EAAcC,KAAMC,KAAON,GACpBI,GAOXZ,EAAEK,GAAGC,YAAYI,SAAW,CAC1BK,aAAgB,EAChBC,YAAe,EACfC,SAAa,EACbC,gBAAmB,oHACnBC,cAAiB,2CACjBC,mBAAoB,EACpBC,iBAAmB,EACnBC,QAAY,EACZC,YAAe,EACfC,cAAgB,EAChBC,cAAgB,EAChBC,QAAa,GACbC,mBAAoB,EACpBC,gBAAkB,EAClBC,cAAgB,EAChBC,mBAAoB,GAEtB,IAMIC,EAAgB,SAASC,GAC3B,OAAOA,EAAIC,QAAQ,MAAO,IAAIA,QAAQ,MAAO,MAG3CC,EAAgB,KAKhBC,EAAY,WACdnC,EAAE,mBAAmBoC,KAAK,WACxB,IACIC,EADUvB,KAAKwB,aAAa,MACVL,QAAQ,QAAS,IACvCnB,KAAKyB,aAAa,KAAMF,MA6BxBG,EAAe,WAEjB1B,KAAK2B,SAAW,GAChB3B,KAAK4B,WAAa,EAClB,IAAIC,EAAS,CACXC,MAAO,MACPC,QAAS,QAEN/B,KAAKgB,kBACRa,EAAOG,QAAQ,CAAC,aAEhBH,EAAOG,QAAQ,CAAC,IAEbhC,KAAKU,eACRmB,EAAOI,OAAO,0BAEhB,IAAIC,EAAKlC,KACTd,EAAEiD,IAAIC,MAAMC,IAAIC,IAAI,QAAQT,IAASU,KAAK,SAASC,GACjD,IAAIC,EAASD,EAAKE,MAElBR,EAAGS,MAAQtD,EAAK,WACdW,KAAK4C,IAAI,MACT5C,KAAK6C,MAAM,SACX7C,KAAK6C,MAAM,eACPX,EAAGlB,mBACLhB,KAAK6C,MAAM,aAEb7C,KAAK6C,MAAM,WACX7C,KAAK6C,MAAM,OACXJ,EAAOK,QAAQ,SAAUC,GAGvB,IAAIC,EAAW,IAAIC,KAAKF,EAAUG,YAAYC,UAC3B,IAAIF,KAAKf,EAAGN,YAAYuB,UACvCH,IACFd,EAAGN,WAAamB,EAAUG,YAE5B,IAAIE,EAAUL,EAAUM,KAAKC,IAAI,SAASC,GACxC,OAAOA,EAAEC,OAEsB,MAA9BT,EAAUU,mBAA4BV,EAAUU,iBAAmB,IACtE,IAAIC,EAAWN,EAAQO,KAAK,MACxBD,EAASE,OAAS,IACpBF,EAAW,aAEb,IAAIG,EAAc,CAChBC,GAAQC,OAAOhB,EAAUe,IACzBE,MAAUD,OAAOhB,EAAUiB,OAC3BC,YAAcF,OAAOhB,EAAUmB,gBAC/BC,QAAWJ,OAAOhB,EAAUqB,cAC5BC,IAAQX,GAEJxB,EAAGlB,oBACP6C,EAAWS,UAAUP,OAAOhB,EAAUuB,YAExCtE,KAAKuE,IAAIV,GACT,IAxGkBW,EACpBC,EAuGMC,EAAWxC,EAAGtB,QAAUmC,EAAUV,IACtCH,EAAGP,SAASoB,EAAUe,IAAM,CAC1BE,MAAOjB,EAAUiB,MACjBC,YAAalB,EAAUmB,eACvBC,SA5GgBK,EA4GIX,EAAWM,QA3GnCM,EAAI,IAAIxB,KAAKuB,GAEVC,EAAEE,UAAY,IADJ,CAAC,UAAW,WAAY,QAAS,QAAS,MAAO,OAAQ,OAAQ,SAAU,YAAa,UAAW,WAAY,YAC1FF,EAAEG,YAAc,IAAMH,EAAEI,eA0GtDC,KAAMJ,EACNrB,KAAMD,GAGJlB,EAAGrB,mBACLkE,OAAOC,OAAO9C,EAAGP,SAASoB,EAAUe,IAAK5B,EAAGrB,kBAAkBkC,KAG/D/C,QAEL,IACE,IAAIiF,EAAahE,EAAciB,EAAGtB,SAClCsE,aAAaC,QAAS,SAAWF,EAAa,aAAeG,KAAKC,UAAUnD,EAAGS,QAC/EuC,aAAaC,QAAS,SAAWF,EAAa,YAAcG,KAAKC,UAAUnD,EAAGP,WAC9EuD,aAAaC,QAAS,SAAWF,EAAa,cAAgB/C,EAAGN,YACjE,MAAO0D,GACPnG,QAAQoG,KAAK,6CAA+CD,GAE1DpD,EAAGnB,cACLmB,EAAGnB,eAELmB,EAAGsD,QAAS,KAIZ1F,EAAgB,CAElB0F,QAAW,EAEXzF,KAAS,SAAU0F,EAAS/F,GAC1B,IAAIgG,EAAO1F,KAIX,GAHA0F,EAAKD,OAASA,EACdV,OAAOC,OAAOhF,KAAMN,GACpBP,QAAQC,IAAI,qBACPM,EAAKQ,WAAa,CAIrByF,OAAOC,WAHP,WACEF,EAAKG,WAEiB,QAExBJ,EAAOK,MAAM,WACXJ,EAAKG,YAITJ,EAAOM,QAAQ,QAAQC,OAAO,SAASV,GACrCA,EAAEW,iBACFP,EAAKQ,KAAKT,EAAOU,SAGfzG,EAAKS,UAKPsF,EAAOW,QAAQ,SAASC,GACtB,GAAoB,KAAhBA,EAAMC,MACR,OAAO,IAGXb,EAAOc,MAAM,SAASF,GACpBX,EAAKQ,KAAKT,EAAOU,WAOvBN,QAAY,WAEV,IAAI7F,KAAKwF,OAAQ,CAEXxF,KAAKc,gBACPd,KAAKc,iBAIP,IACE,IAAImE,EAAahE,EAAcjB,KAAKY,SACpCZ,KAAK2C,MAAQuC,aAAasB,QAAS,SAAWvB,EAAa,cAC3DjF,KAAK2B,SAAWuD,aAAasB,QAAS,SAAWvB,EAAa,aAC9DjF,KAAK4B,WAAasD,aAAasB,QAAS,SAAWvB,EAAa,eAC5DjF,KAAK4B,YAAc5B,KAAK2C,OAAS3C,KAAK2B,WACxC3B,KAAK4B,WAAa5B,KAAK4B,WACvB5B,KAAK2C,MAAQtD,EAAKoH,MAAMC,KAAKtB,KAAKuB,MAAM3G,KAAK2C,QAC7C3C,KAAK2B,SAAWyD,KAAKuB,MAAM3G,KAAK2B,UAChC3B,KAAKwF,QAAS,GAEhB,MAAOF,GACPnG,QAAQoG,KAAK,mDAAqDD,IAGtE,GAAItF,KAAKwF,OAAQ,CAGf,IAAI3D,EAAS,CACXC,MAAO,MACPG,OAAQ,gBAAmBjC,KAAK4B,WAAWT,QAAQ,OAAQ,IAAIA,QAAQ,IAAK,KAAO,IACnFyF,OAAQ,MAEN1E,EAAKlC,KACTd,EAAEiD,IAAIC,MAAMC,IAAIC,IAAI,QAAST,IAASU,KAAK,SAASC,GAC1B,EAApBA,EAAKE,MAAMkB,OACblC,EAAamF,KAAK3E,IAEdA,EAAGnB,cACLmB,EAAGnB,eAELmB,EAAGsD,QAAS,UAKhB9D,EAAamF,KAAK7G,OAKtBkG,KAAW,SAASY,GAClBC,aAAa3F,GACR0F,IACHA,EAAQ,IAEVA,EAAQA,EAAME,cACd5F,EAAgBwE,WAAW,WAKzB,IAHA,IAAIqB,EAAc,GAEdC,EAAaJ,EAAMK,MAAM,OACpBC,EAAE,EAAEC,EAAKH,EAAWtD,OAAOwD,EAAEC,EAAKD,IAAK,CAE9C,IAAI7D,EAAI2D,EAAWE,GACd7D,GACL0D,EAAYK,KAAKtH,KAAK2C,MAAM4E,MAAM,SAAUC,GAK1CA,EAAEC,KAAKlE,EAAG,CACRmE,aAAa,EACbC,MAAO,MAGTH,EAAEC,KAAKlE,EAAG,CACRmE,aAAa,EACbC,MAAO,GACPC,SAAUvI,EAAKwI,MAAMD,SAASE,WAGhCN,EAAEC,KAAKlE,EAAG,CACRmE,aAAa,EACbK,aAAc,EACdJ,MAAO,OAKb,GAAyB,EAArBV,EAAYrD,OAAY,CAQ1B,IAAIoE,EAAef,EAAY,GAC/BA,EAAcA,EAAYgB,MAAM,GAChC,IAASb,EAAEY,EAAapE,OAAO,GAAK,EAAHwD,EAAKA,IAAK,CACzC,IAAIxE,EAAMoF,EAAaZ,GAAGxE,IAC1B,IAAKsF,EAAE,EAAEC,KAAKlB,EAAYrD,OAAOsE,EAAEC,KAAKD,IAAK,CAE3C,IADA,IAAIE,EAAY,GACPC,EAAE,EAAEC,EAAKrB,EAAYiB,GAAGtE,OAAOyE,EAAEC,EAAKD,IAC7CD,EAAUnB,EAAYiB,GAAGG,GAAGzF,MAAO,EAErC,IAAKwF,EAAUxF,GAAM,CACnBoF,EAAeA,EAAaC,MAAM,EAAGb,GAAGmB,OAAOP,EAAaC,MAAMb,EAAE,IACpE,cAMNY,EAFgC,IAAvBf,EAAYrD,OAENqD,EAAY,GAGZ,GAGjB,IAAIpH,EAAYX,EAAEc,KAAKH,SACnBI,EAAe,GACS,IAAxB+H,EAAapE,QACf/D,EAAQ2I,QACJxI,KAAKM,mBAAqBN,KAAKO,iBACjCV,EAAQ4I,OAAOzI,KAAK0I,OAAO1I,KAAKK,cAAc,CAACsI,OAAS,MAEjD3I,KAAKM,oBACO,EAAjBT,EAAQ+D,OACV/D,EAAQ+I,WAAWC,GAAG,GAAGC,YAAY9I,KAAK0I,OAAO1I,KAAKK,cAAc,CAACsI,OAASX,EAAapE,UAE3F/D,EAAQ4I,OAAOzI,KAAK0I,OAAO1I,KAAKK,cAAc,CAACsI,OAASX,EAAapE,WAItE5D,KAAKQ,QACNR,KAAKQ,SAIP,IAAS4G,EAAI,EAAGA,EAAIY,EAAapE,OAAQwD,IAAK,CAC5C,IAAI2B,EAAWf,EAAaZ,GAAGxE,IAC3BoG,EAAahJ,KAAK2B,SAASoH,GAC3BC,GACFA,EAASpG,IAAMmG,EACf9I,EAAYqH,KAAK0B,IAEjB7J,QAAQoG,KAAK,2CAIjB,IAAI0D,EAAY/J,EAAE,mBACdgK,EAAcD,EACjB3F,IAAI,WACH,OAAOtD,KAAK8D,GAAGmE,MAAM,KACpB9F,MACH,GAA2B,IAAvB+G,EAAYtF,OAAc,CAC5B,IAASwD,EAAE,EAAEC,EAAKpH,EAAY2D,OAAOwD,EAAEC,EAAKD,IAC1CvH,EAAQ4I,OAAOzI,KAAK0I,OAAO1I,KAAKI,gBAAgBH,EAAYmH,KAE9D/F,QACK,CAEL,IAAI8H,EAAU,GACd,IAAS/B,EAAE,EAAEC,EAAKW,EAAapE,OAAOwD,EAAEC,EAAKD,IAC3C+B,EAAQ7B,KAAKU,EAAaZ,GAAGxE,KAG/B,IACIwG,EADc,IAAIC,YAAYH,EAAaC,GACvBG,YAnUT,SAASL,EAAWM,EAASH,GAClD,IAAK,IAAIhC,EAAE,EAAEC,EAAK+B,EAAMxF,OAAOwD,EAAEC,EAAKD,IAAK,CACzC,IAAIoC,EAAOJ,EAAMhC,GACjB,GAAe,UAAXoC,EAAK,GACPP,EAAUJ,GAAGW,EAAK,GAAG,GAAGC,aACnB,CACL,IAAIV,EAAUQ,EAAQC,EAAK,GAAG,GAAG5G,IAC7BoG,EAAWhJ,KAAK2B,SAASoH,GACzBW,EAAO1J,KAAK0I,OAAO1I,KAAKI,gBAAgB4I,GAC5C,GAAgB,eAAZQ,EAAK,GACPP,EAAUJ,GAAGW,EAAK,GAAG,GAAGV,YAAYY,QAC/B,GAAgB,WAAZF,EAAK,GAAiB,CAC/B,IAAIG,EAEFA,EADc,IAAZH,EAAK,GACD,KAECA,EAAK,GAAG,EAEjBP,EAAUJ,GAAGc,GAAKC,MAAMF,KAI9BrI,MA+SuBwF,KAAK7G,KAAMiJ,EAAWjB,EAAcoB,GAGpDpJ,KAAKS,YACNT,KAAKS,WAAWR,IAElB4J,KAAK7J,MAAO,MAGhB8J,MAAW,WACT5K,EAAEc,KAAKH,SAAS2I,QAChBxI,KAAKyF,OAAOU,IAAI,KAGlBuC,OAAY,SAAUqB,EAAGtF,GACvB,OAAOsF,EAAE5I,QAAQ,gBAAiB,SAAU6I,EAAGC,GAC7C,IAAIC,EAAIzF,EAAEwF,GACV,MAAoB,iBAANC,GAA+B,iBAANA,EAAiBA,EAAIF,MAvZpE,CA4ZIG","file":"ghostHunter.js","sourcesContent":["/**\n * ghostHunter - 0.5.1\n * Copyright (C) 2014 Jamal Neufeld (jamal@i11u.me)\n * MIT Licensed\n * @license\n */\n(function( $ ) {\n\n  console.log(333333);\n\n  /* Include the Lunr library */\n  var lunr=require('/lunr.min.js');\n\n  /* LEVENSHTEIN */\n\n  //This is the main plugin definition\n  $.fn.ghostHunter \t= function( options ) {\n\n    //Here we use jQuery's extend to set default values if they weren't set by the user\n    var opts \t\t= $.extend( {}, $.fn.ghostHunter.defaults, options );\n    if( opts.results )\n    {\n      pluginMethods.init( this , opts );\n      return pluginMethods;\n    }\n  };\n\n  // If the Ghost instance is in a subpath of the site, set subpath\n  // as the path to the site with a leading slash and no trailing slash\n  // (i.e. \"/path/to/instance\").\n  $.fn.ghostHunter.defaults = {\n    resultsData\t\t\t: false,\n    onPageLoad\t\t\t: false,\n    onKeyUp\t\t\t\t: false,\n    result_template \t: \"<a id='gh-{{ref}}' class='gh-search-item' href='{{link}}'><p><h2>{{title}}</h2><h4>{{prettyPubDate}}</h4></p></a>\",\n    info_template\t\t: \"<p>Number of posts found: {{amount}}</p>\",\n    displaySearchInfo\t: true,\n    zeroResultsInfo\t\t: true,\n    before\t\t\t\t: false,\n    onComplete\t\t\t: false,\n    includepages\t\t: false,\n    filterfields\t\t: false,\n    subpath\t\t\t\t: \"\",\n    item_preprocessor\t: false,\n    indexing_start\t\t: false,\n    indexing_end\t\t: false,\n    includebodysearch\t: false\n  };\n  var prettyDate = function(date) {\n    var d = new Date(date);\n    var monthNames = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\n    return d.getDate() + ' ' + monthNames[d.getMonth()] + ' ' + d.getFullYear();\n  };\n\n  var getSubpathKey = function(str) {\n    return str.replace(/^\\//, \"\").replace(/\\//g, \"-\")\n  };\n\n  var lastTimeoutID = null;\n\n  // We add a prefix to new IDs and remove it after a set of\n  // updates is complete, just in case a browser freaks over\n  // duplicate IDs in the DOM.\n  var settleIDs = function() {\n    $('.gh-search-item').each(function(){\n      var oldAttr = this.getAttribute('id');\n      var newAttr = oldAttr.replace(/^new-/, \"\");\n      this.setAttribute('id', newAttr);\n    });\n  };\n\n  var updateSearchList = function(listItems, apiData, steps) {\n    for (var i=0,ilen=steps.length;i<ilen;i++) {\n      var step = steps[i];\n      if (step[0] == \"delete\") {\n        listItems.eq(step[1]-1).remove();\n      } else {\n        var lunrref = apiData[step[2]-1].ref;\n        var postData = this.blogData[lunrref];\n        var html = this.format(this.result_template,postData);\n        if (step[0] === \"substitute\") {\n          listItems.eq(step[1]-1).replaceWith(html);\n        } else if (step[0] === \"insert\") {\n          var pos;\n          if (step[1] === 0) {\n            pos = null;\n          } else {\n            pos = (step[1]-1)\n          }\n          listItems.eq(pos).after(html);\n        }\n      }\n    }\n    settleIDs();\n  }\n\n  var grabAndIndex = function(){\n    // console.log('ghostHunter: grabAndIndex');\n    this.blogData = {};\n    this.latestPost = 0;\n    var params = {\n      limit: \"all\",\n      include: \"tags\",\n    };\n    if ( this.includebodysearch ){\n      params.formats=[\"plaintext\"]\n    } else {\n      params.formats=[\"\"]\n    }\n    if ( this.includepages ){\n      params.filter=\"(page:true,page:false)\";\n    }\n    var me = this;\n    $.get(ghost.url.api('posts',params)).done(function(data){\n      var idxSrc = data.posts;\n      // console.log(\"ghostHunter: indexing all posts\")\n      me.index = lunr(function () {\n        this.ref('id');\n        this.field('title');\n        this.field('description');\n        if (me.includebodysearch){\n          this.field('plaintext');\n        }\n        this.field('pubDate');\n        this.field('tag');\n        idxSrc.forEach(function (arrayItem) {\n          // console.log(\"start indexing an item: \" + arrayItem.id);\n          // Track the latest value of updated_at,  to stash in localStorage\n          var itemDate = new Date(arrayItem.updated_at).getTime();\n          var recordedDate = new Date(me.latestPost).getTime();\n          if (itemDate > recordedDate) {\n            me.latestPost = arrayItem.updated_at;\n          }\n          var tag_arr = arrayItem.tags.map(function(v) {\n            return v.name; // `tag` object has an `name` property which is the value of tag. If you also want other info, check API and get that property\n          })\n          if(arrayItem.meta_description == null) { arrayItem.meta_description = '' };\n          var category = tag_arr.join(\", \");\n          if (category.length < 1){\n            category = \"undefined\";\n          }\n          var parsedData \t= {\n            id \t\t\t: String(arrayItem.id),\n            title \t\t: String(arrayItem.title),\n            description\t: String(arrayItem.custom_excerpt),\n            pubDate \t: String(arrayItem.published_at),\n            tag \t\t: category\n          }\n          if  ( me.includebodysearch ){\n            parsedData.plaintext=String(arrayItem.plaintext);\n          }\n          this.add(parsedData)\n          var localUrl = me.subpath + arrayItem.url\n          me.blogData[arrayItem.id] = {\n            title: arrayItem.title,\n            description: arrayItem.custom_excerpt,\n            pubDate: prettyDate(parsedData.pubDate),\n            link: localUrl,\n            tags: tag_arr\n          };\n          // If there is a metadata \"pre\"-processor for the item, run it here.\n          if (me.item_preprocessor) {\n            Object.assign(me.blogData[arrayItem.id], me.item_preprocessor(arrayItem));\n          }\n          // console.log(\"done indexing the item\");\n        }, this);\n      });\n      try {\n        var subpathKey = getSubpathKey(me.subpath);\n        localStorage.setItem((\"ghost_\" + subpathKey + \"_lunrIndex\"), JSON.stringify(me.index));\n        localStorage.setItem((\"ghost_\" + subpathKey + \"_blogData\"), JSON.stringify(me.blogData));\n        localStorage.setItem((\"ghost_\" + subpathKey + \"_latestPost\"), me.latestPost);\n      } catch (e) {\n        console.warn(\"ghostHunter: save to localStorage failed: \" + e);\n      }\n      if (me.indexing_end) {\n        me.indexing_end();\n      }\n      me.isInit = true;\n    });\n  }\n\n  var pluginMethods\t= {\n\n    isInit\t\t\t: false,\n\n    init\t\t\t: function( target , opts ){\n      var that = this;\n      that.target = target;\n      Object.assign(this, opts);\n      console.log(\"ghostHunter: init\");\n      if ( opts.onPageLoad ) {\n        function miam () {\n          that.loadAPI();\n        }\n        window.setTimeout(miam, 1);\n      } else {\n        target.focus(function(){\n          that.loadAPI();\n        });\n      }\n\n      target.closest(\"form\").submit(function(e){\n        e.preventDefault();\n        that.find(target.val());\n      });\n\n      if( opts.onKeyUp ) {\n        // In search-as-you-type mode, the Enter key is meaningless,\n        // so we disable it in the search field. If enabled, some browsers\n        // will save data to history (even when autocomplete=\"false\"), which\n        // is an intrusive headache, particularly on mobile.\n        target.keydown(function(event){\n          if (event.which === 13) {\n            return false;\n          }\n        });\n        target.keyup(function(event) {\n          that.find(target.val());\n        });\n\n      }\n\n    },\n\n    loadAPI\t\t\t: function(){\n      // console.log('ghostHunter: loadAPI');\n      if(!this.isInit) {\n        // console.log('ghostHunter: this.isInit is true');\n        if (this.indexing_start) {\n          this.indexing_start();\n        }\n        // If isInit is falsy, check for data in localStore,\n        // parse into memory, and declare isInit to be true.\n        try {\n          var subpathKey = getSubpathKey(this.subpath);\n          this.index = localStorage.getItem((\"ghost_\" + subpathKey + \"_lunrIndex\"));\n          this.blogData = localStorage.getItem((\"ghost_\" + subpathKey + \"_blogData\"));\n          this.latestPost = localStorage.getItem((\"ghost_\" + subpathKey + \"_latestPost\"));\n          if (this.latestPost && this.index && this.blogData) {\n            this.latestPost = this.latestPost;\n            this.index = lunr.Index.load(JSON.parse(this.index));\n            this.blogData = JSON.parse(this.blogData);\n            this.isInit = true;\n          }\n        } catch (e){\n          console.warn(\"ghostHunter: retrieve from localStorage failed: \" + e);\n        }\n      }\n      if (this.isInit) {\n        // console.log('ghostHunter: this.isInit recheck is true');\n        // Check if there are new or edited posts\n        var params = {\n          limit: \"all\",\n          filter: \"updated_at:>\\'\" + this.latestPost.replace(/\\..*/, \"\").replace(/T/, \" \") + \"\\'\",\n          fields: \"id\"\n        };\n        var me = this;\n        $.get(ghost.url.api('posts', params)).done(function(data){\n          if (data.posts.length > 0) {\n            grabAndIndex.call(me);\n          } else {\n            if (me.indexing_end) {\n              me.indexing_end();\n            }\n            me.isInit = true;\n          }\n        });\n      } else {\n        // console.log('ghostHunter: this.isInit recheck is false');\n        grabAndIndex.call(this)\n      }\n    },\n\n\n    find \t\t \t: function(value){\n      clearTimeout(lastTimeoutID);\n      if (!value) {\n        value = \"\";\n      };\n      value = value.toLowerCase();\n      lastTimeoutID = setTimeout(function() {\n        // Query strategy is lifted from comments on a lunr.js issue: https://github.com/olivernn/lunr.js/issues/256\n        var thingsFound = [];\n        // The query interface expects single terms, so we split.\n        var valueSplit = value.split(/\\s+/);\n        for (var i=0,ilen=valueSplit.length;i<ilen;i++) {\n          // Fetch a list of matches for each term.\n          var v = valueSplit[i];\n          if (!v) continue;\n          thingsFound.push(this.index.query(function (q) {\n            // For an explanation of lunr indexing options, see the lunr.js\n            // documentation at https://lunrjs.com/docs/lunr.Query.html#~Clause\n\n            // look for an exact match and apply a large positive boost\n            q.term(v, {\n              usePipeline: true,\n              boost: 100,\n            });\n            // look for terms that match the beginning of this queryTerm and apply a medium boost\n            q.term(v, {\n              usePipeline: false,\n              boost: 10,\n              wildcard: lunr.Query.wildcard.TRAILING\n            });\n            // look for terms that match with an edit distance of 1 and apply a small boost\n            q.term(v, {\n              usePipeline: false,\n              editDistance: 1,\n              boost: 1\n            });\n          }));\n        }\n        var searchResult;\n        if (thingsFound.length > 1) {\n          // If we had multiple terms, we'll have multiple lists. We filter\n          // them here to use only items that produce returns for all\n          // terms. This spoofs an AND join between terms, which lunr.js can't\n          // yet do internally.\n          // By using the first list of items as master, we get weightings\n          // based on the first term entered, which is more or less\n          // what we would expect.\n          var searchResult = thingsFound[0];\n          thingsFound = thingsFound.slice(1);\n          for (var i=searchResult.length-1;i>-1;i--) {\n            var ref = searchResult[i].ref;\n            for (j=0,jlen=thingsFound.length;j<jlen;j++) {\n              var otherRefs = {}\n              for (var k=0,klen=thingsFound[j].length;k<klen;k++) {\n                otherRefs[thingsFound[j][k].ref] = true;\n              }\n              if (!otherRefs[ref]) {\n                searchResult = searchResult.slice(0, i).concat(searchResult.slice(i+1));\n                break;\n              }\n            }\n          }\n        } else if (thingsFound.length === 1) {\n          // If we had just one term and one list, return that.\n          searchResult = thingsFound[0];\n        } else {\n          // If there was no search result, return an empty list.\n          searchResult = [];\n        }\n\n        var results \t\t= $(this.results);\n        var resultsData \t= [];\n        if (searchResult.length === 0) {\n          results.empty();\n          if (this.displaySearchInfo && this.zeroResultsInfo) {\n            results.append(this.format(this.info_template,{\"amount\":0}));\n          }\n        } else if (this.displaySearchInfo) {\n          if (results.length > 0) {\n            results.children().eq(0).replaceWith(this.format(this.info_template,{\"amount\":searchResult.length}));\n          } else {\n            results.append(this.format(this.info_template,{\"amount\":searchResult.length}));\n          }\n        }\n\n        if(this.before) {\n          this.before();\n        };\n\n        // Get the blogData for the full set, for onComplete\n        for (var i = 0; i < searchResult.length; i++) {\n          var lunrref\t\t= searchResult[i].ref;\n          var postData  \t= this.blogData[lunrref];\n          if (postData) {\n            postData.ref = lunrref;\n            resultsData.push(postData);\n          } else {\n            console.warn(\"ghostHunter: index/data mismatch. Ouch.\");\n          }\n        }\n        // Get an array of IDs present in current results\n        var listItems = $('.gh-search-item');\n        var currentRefs = listItems\n        .map(function(){\n          return this.id.slice(3);\n        }).get();\n        if (currentRefs.length === 0) {\n          for (var i=0,ilen=resultsData.length;i<ilen;i++) {\n            results.append(this.format(this.result_template,resultsData[i]));\n          }\n          settleIDs();\n        } else {\n          // Get an array of IDs present in searchResult\n          var newRefs = [];\n          for (var i=0,ilen=searchResult.length;i<ilen;i++) {\n            newRefs.push(searchResult[i].ref)\n          }\n          // Get the Levenshtein steps needed to transform current into searchResult\n          var levenshtein = new Levenshtein(currentRefs, newRefs);\n          var steps = levenshtein.getSteps();\n          // Apply the operations\n          updateSearchList.call(this, listItems, searchResult, steps);\n        }\n        // Tidy up\n        if(this.onComplete) {\n          this.onComplete(resultsData);\n        };\n      }.bind(this), 100);\n    },\n\n    clear \t\t\t: function(){\n      $(this.results).empty();\n      this.target.val(\"\");\n    },\n\n    format \t\t\t: function (t, d) {\n      return t.replace(/{{([^{}]*)}}/g, function (a, b) {\n        var r = d[b];\n        return typeof r === 'string' || typeof r === 'number' ? r : a;\n      });\n    }\n  }\n\n})( jQuery );"],"sourceRoot":"/source/"}